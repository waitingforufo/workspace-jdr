// 所有权规则

// 所有权有一下三条规则：
//   - Rust中的每个值都有一个变量，称为其所有者
//   - 一次只能有一个所有者
//   - 当所有者不再程序运行范围时，该值将被删除
// 这三条规则是所有权概念的基础。

pub fn suoyouquan_lianxi(){

    // 变量范围 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    {
        // 在声明一下，变量s无效

        let s = "hello,JDR";
        // 这里是变量s的可用范围
    }
    // 变量范围已结束，变量s无效
    // *变量范围是变量的一个属性，其代表变量的可行域，默认从声明变量开始有效直到变量所在域结束
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    // 内存和分配 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // 定义一个变量，赋予一个值，这个变量的值存在于内存中。
    //   这种情况很普遍，但是如果需要存储的数据长度不确定（比如用户输入的字符串），就无法在定义时明确数据长度，
    //   也就无法在编译阶段令程序分配固定长度的内存空间供数据存储使用。
    //   这就需要提供一种在程序运行时程序自己申请使用内存的机制 - 堆。
    // “内存资源”都指的是 堆 所占用的内存空间。
    // 有分配就有释放
    // e.g.:
    //  一下是 C语言的等价编写：
    // {
    //     char *s = strdup("JDR");
    //     free(s);
    // }
    // Rust中没有调用 free 函数来释放字符串s的资源。Rust之所以没有明示释放的步骤是因为变量范围结束的时候，Rust编译器自动添加了调用释放资源函数的步骤。
    // 这种机制看似很简单了：它不过是帮助程序员在适当的地方添加了一个释放资源的函数调用而已。
    //   这种简单的机制可以有效地解决一个史上最令人头疼的编程问题。
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    // 变量与数据交互的方式 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // 主要有两种： 移动(Move) , 克隆(Clone)

    // 移动
    //   多个变量可以在Rust中以不同的方式与相同的数据交互：

    let x = 5;
    let y = x;
    println!("y = {}", y);
    println!("x = {}", x);  // OK 栈 里的变量赋值不会转移所有权(只是单纯的值复制)
    // 这个程序将值 5 绑定到变量 x， 然后将 x 的值复制并赋值给变量 y。
    //   现在 栈 中有两个值 5. 此情况中的数据是“基本数据”类型的数据，不需要存储到堆中，仅在 栈 中的数据的“移动”方式是直接复制，
    //   它不会花费更长的时间或更多的存储空间。
    // “基本数据”类型：
    //   - 所有的整数类型， 例如 i32, u32, i64 etc.
    //   - 布尔类型 bool， 值为 true / false
    //   - 所有浮点类型， f32 和 f64
    //   - 字符类型 char
    //   - 仅包含以上类型数据的元祖（Tuples）

    // 但如果发生交互的数据在 堆 中就是另外一种情况：
    let s1 = String::from("hello");
    let s2 = s1;
    println!("s2 = {}", s2);
    //println!("s1 = {}", s1);  // NG s1的所有权被转移到s2

    // 第一步产生一个 String对象，值为“hello”。 其中“hello”可以认为是类似于长度不确定的数据，需要在 堆中存储。
    //   第二步的情况略有不同， 所有权会被转移。

    // 克隆
    // 想要将数据单纯地复制一份以供他用，可以使用数据的第二种交互方式 - 克隆。
    // 示例：
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    // 涉及函数的所有权机制 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // 如果将一个变量当作参数传递给函数，怎样安全地处理所有权？
    // 示例：
    let s = String::from("hello");
    // s被声明，有效

    takes_ownership(s);
    // s的值被当作参数传入函数，所以当作 s 已经被移动，从这里开始 s 已经无效
    // println!("s: {}", s);  // NG  s无效

    let x = 5;
    // x 被声明，有效

    makes_copy(x);
    // x的值被当作参数传入函数
    // 但 x 是基本类型，依然有效（没有被释放，所有权没有被转移）
    // 在这里依然可以使用 x
    println!("x 的值依然存在： {}", x);
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    // 函数返回值的所有权机制 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    let s1 = gives_ownership();
    // gives_ownership移动它的返回值到 s1
    println!("s1 = {}", s1);

    let s2 = String::from("hello");
    // s2被声明有效

    let s3 = takes_and_gives_back(s2);
    println!("s3 = {}", s3);
    //println!("s2 = {}", s2);  // NG 所有权被转移到函数里，然后被转移到 s3

    // 被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    println!("引用与租借练习");
    // 引用与租借 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // 引用(Reference)是C++熟悉的概念
    // 可以当作一种指针， 实质上“引用”是变量的间接访问方式
    // e.g.:
    let s1 = String::from("hello");
    let s2 = &s1;     // 引用赋值 s2指向s1同样的内存空间（不会重新分配新的内存空间）
    println!("s2 = {}", s2);
    println!("s1 = {}", s1);  // OK s1所有权不变
    // 引用 不会获得值得所有权。
    // 引用 只能租借(Borrow)值得所有权。
    // 引用 本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值得所有有权。

    // e.g.:
    let s1 = String::from("hello");
    let mut s2 = &s1;
    println!("s2: {}", s2);

    //let s3 = s1;  // NG 无法把s1转给s3， 因为s1已经借给s2了

    println!(" s3 <- s2");
    let s3 = s2;  // s2本身是借用 &String, 所以赋值给s3 也是借用
    println!("s3: {}", s3);
    println!("s2: {}", s2);

    let mut s = String::from("hello");
    let r1 = &mut s;
    //let r2 = &mut s;  // NG s已经引用给r1， 不能同时租借多个
    //println!("{}, {}", r1, r2);

    // 垂悬引用（Dangling References）
    // 这是一个换了名字的概念，如果放在指针概念里就是那种没有实际指向一个真正能访问的数据的指针（注意不是空指针，还有可能是已经释放的资源）。
    // 它们就像失去悬挂物的绳子，所以叫“垂悬引用”。
    // 垂悬引用在Rust语言里不允许出现，如果有，编译器会发现它。
    // e.g.: 垂悬引用典型案例

    //let reference_to_nothing = dangle();
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

}// 函数结束， x无效，然后是 s 。 但s已被移动，所以不用被释放

fn takes_ownership(some_string: String){
    // 一个String参数 some_string传入，有效
    println!("some_string: {}", some_string);  // some_string: hello
}// 函数结束，参数some_string在这里释放

fn makes_copy(some_integer: i32){
    // 一个 i32参数 some_integer传入，有效
    println!("some_integer: {}", some_integer);
}// 函数结束，参数 some_integer是基本类型，无需释放

fn gives_ownership() -> String{
    let some_string = String::from("hello");
    // some_string被声明，有效

    return some_string;
    // some_string被当做返回值移动出函数
}

fn takes_and_gives_back(a_string: String) -> String {
    // a_string被声明有效

    a_string  // a_string被当做返回值移出函数
}// a_string不会被无效释放，移出函数

// fn dangle() -> &String{
//     let s = String::from("hello");
// 
//     &s
// }// s被释放， 但是其引用又被返回了，Rust里不允许出现